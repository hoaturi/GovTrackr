# GovTrackr: 미국 행정부 활동 추적 어플리케이션

GovTrackr는 백악관 웹사이트의 최신 정보를 수집하고 한국어로 번역, 요약하여 미국 행정부의 주요 정책 변화와 대통령 활동을 제공하는 백엔드 어플리케이션입니다.

## ✨ 주요 기능

  * **정책 활동 API**: 백악관 활동 목록 및 상세 내용을 조회할 수 있는 RESTful API를 제공합니다.
  * **주간 활동 요약 이메일**: 구독자에게 한 주간의 주요 활동을 요약하여 이메일로 발송합니다.
  * **실시간 활동 감지**: 백악관 웹사이트를 주기적으로 모니터링하여 새로운 활동 게시물을 탐지합니다.
  * **자동 콘텐츠 스크래핑**: 새로운 활동이 감지되면 해당 웹페이지의 내용을 자동으로 수집합니다.
  * **AI 기반 번역 및 요약**: 수집된 원문 콘텐츠를 AI를 활용해 한국어로 번역하고 핵심 내용을 요약합니다.

## 💻 사용 기술

  * **언어 및 프레임워크**: C\#, ASP.NET 9
  * **데이터베이스**: PostgreSQL
  * **라이브러리**: MassTransit, Mediatr, Playwright
  * **클라우드 플랫폼**: Azure Functions, AWS SES


## 🏛️ 아키텍처 설계

![1](https://github.com/user-attachments/assets/db83314b-fcc9-447c-b26a-3a182fdc4de8)

각 기능마다 다른 리소스를 필요로함으로 특정 작업을 전담하는 여러 서비스로 분리된 아키텍처를 사용했습니다. 각 주요 기능은 Azure Functions 기반의 독립적인 서비스로 구현하였습니다.

  * **API 서버**: 사용자 요청 처리 및 데이터 조회를 담당하는 핵심 서비스입니다.
  * **활동 감지 서비스 (Azure Function)**: 주기적으로 백악관 웹사이트를 모니터링하여 새로운 게시글을 확인합니다.
  * **스크래핑 서비스 (Azure Function)**: 웹페이지에서 필요한 데이터를 추출합니다.
  * **번역/요약 서비스 (Azure Function)**: 외부 AI API를 이용해 콘텐츠를 번역, 요약합니다.
  * **주간 활동 이메일 발송 서비스 (Azure Function)**: 구독자에게 주간 요약을 발송합니다.

### 서비스 분리 설계: 문제 정의 및 해결 전략

초기 설계 단계에서, 모든 기능을 단일 애플리케이션으로 구축할 경우 발생할 수 있는 몇 가지 주요 문제점을 예상했습니다. 이를 해결하기 위해 백그라운드 서비스들을 분리하는 전략을 선택했습니다.

1.  **문제점: 기능별 리소스 요구량 차이로 인한 비효율성**

      * **예상 문제**: 각 기능은 필요한 컴퓨팅 자원(CPU, 메모리, 실행 시간)이 매우 다릅니다. 예를 들어, 스크래핑은 헤드리스 브라우저 사용으로 일시적인 CPU/메모리 사용량이 매우 높고, AI 번역/요약은 외부 API 호출로 인해 응답 대기 시간이 깁니다(30초\~1분 이상). 만약 이를 단일 애플리케이션으로 운영한다면, 가장 리소스 집약적인 기능(스크래핑)의 최대 부하를 기준으로 전체 시스템의 사양을 맞춰야 합니다. 이는 평상시 API 서버와 같이 상대적으로 낮은 자원을 사용하는 기능에는 심각한 자원 낭비를 초래하며, 특정 기능의 부하가 다른 기능의 성능에 직접적인 영향을 미칠 수 있습니다.
      * **해결 전략: 서비스 분리 및 Azure Functions 도입**: 각 기능의 특성에 맞는 최적의 실행 환경을 제공하고 독립적인 확장을 가능하게 하기 위해, 기능을 별도의 Azure Function 서비스로 분리했습니다. 이를 통해 스크래핑 서비스는 필요 시 높은 사양으로, AI 서비스는 긴 실행 시간을 허용하도록, API 서버는 안정적인 응답성을 유지하도록 개별적으로 관리 및 확장할 수 있게 되어 리소스 활용 효율성을 극대화했습니다.

2.  **문제점: 간헐적 작업 부하로 인한 운영 비용 증가**

      * **예상 문제**: 스크래핑, AI 처리, 이메일 발송과 같은 작업은 매 순간 실행되는 것이 아니라 특정 조건(새 활동 감지, 정해진 시간)에 따라 간헐적으로 실행됩니다. 만약 이러한 기능들이 항상 실행 중인 단일 애플리케이션 서버의 일부라면, 해당 기능이 유휴 상태일 때도 자원을 계속 점유하여 불필요한 운영 비용이 발생할 수 있습니다.
      * **해결 전략: 서버리스 아키텍처(Azure Functions) 활용**: 간헐적으로 실행되는 작업들을 Azure Functions의 Consumption Plan 기반으로 구현했습니다. 이를 통해 실제 코드가 실행되는 시간에 대해서만 비용을 지불하게 되어, 유휴 시간에 대한 비용을 절감하고 전체 운영 비용의 효율성을 높였습니다.

3.  **문제점: 특정 기능의 장애 또는 부하가 전체 서비스에 미치는 영향**

      * **예상 문제**: 단일 애플리케이션 구조에서는 특정 기능(예: 스크래핑)에서 예기치 않은 오류가 발생하거나 과도한 부하가 걸릴 경우, 해당 문제점이 애플리케이션 전체로 전파되어 API 서버를 포함한 모든 기능이 마비될 위험이 있습니다.
      * **해결 전략: 서비스 분리를 통한 장애 격리 및 안정성 확보**: 각 기능을 독립된 서버리스 서비스로 분리함으로써, 특정 서비스의 문제(오류, 부하 급증)가 다른 서비스로 전파되는 것을 차단했습니다. 예를 들어, 스크래핑 서비스가 일시적으로 많은 자원을 사용하더라도 API 서버의 응답 속도에는 영향을 미치지 않습니다. 또한, 스크래핑 서비스 내부에 세마포어를 이용하여 동시에 처리하는 웹페이지 수를 제한하여 과도한 리소스 사용을 방지하였습니다.

## 📊 데이터 모델 (ERD)

![diagram](https://github.com/user-attachments/assets/9a47984e-a276-4b5a-8542-2c56e5db654c)

## 💡 주요 기술 결정 및 구현 상세


### 1\. 비동기 처리 및 서비스 간 통신: 메시지 큐 (MassTransit & Azure Service Bus)

  * **워크플로우**: `활동 감지` → `스크래핑 요청` → `번역/요약 요청`으로 이어지는 작업 흐름은 메시지 큐를 통해 비동기적으로 처리됩니다. 각 단계의 작업은 큐에 메시지로 전달되고, 해당 서비스는 이 메시지를 소비하여 작업을 수행합니다.
  * **선택 이유**:
      * **느슨한 결합**: 서비스들이 메시지를 통해서만 상호작용하므로 직접적인 의존성이 낮아져 독립적인 개발, 배포, 수정이 용이합니다.
      * **오류 처리**: 메시지 처리 중 일시적 오류(예: 네트워크 문제) 발생 시, MassTransit 미들웨어가 자동으로 재시도를 수행하여 작업 흐름의 안정성을 높입니다.
      * **Azure Functions 통합**: Azure Service Bus는 Azure Functions 트리거와 자연스럽게 연동되어 구현이 간편합니다.

### 2\. 예측 가능한 오류 처리: Result 패턴

  * **배경**: 시스템 오류처럼 예측 불가능하고 즉시 복구 어려운 심각한 문제에는 예외를 사용하되, 비즈니스 로직 상 충분히 예상 가능한 실패(예: 데이터 형식 불일치, 정보 누락)는 `Result` 객체를 통해 명시적으로 처리합니다.
  * **적용 사례**:
      * **스크래핑 실패**: 웹페이지 구조 변경으로 제목 등 필수 정보 추출 실패 시, 이는 시스템 오류가 아닌 예측 가능한 실패로 간주하여 `Result.Fail`을 반환합니다. 이를 통해 MassTransit의 불필요한 재시도를 방지합니다.
      * **AI 번역 결과 오류**: AI 응답 형식이 예상된 JSON 구조와 다를 경우, 외부 서비스의 일시적 문제일 수 있으므로 의도적으로 예외를 발생시켜 MassTransit을 통해 재시도를 유도합니다.
  * **오류 객체 표준화**: `Result.Fail` 반환 시 사용되는 오류 객체를 일관성 있게 생성하기 위해 **Factory 패턴**을 도입하여 오류 정보의 표준화 및 처리 로직의 가독성/유지보수성을 개선했습니다.

### 3\. 향후 확장을 위한 설계: Strategy 패턴

  * **배경**: 추후 백악관 외 다른 출처나 문서 형식을 지원할 가능성을 고려했습니다.
  * **구현**: **스크래핑 로직**과 **번역/요약 로직**을 인터페이스 기반으로 추상화하고, 실제 구현체는 **Strategy 패턴**을 적용했습니다. 이를 통해 특정 문서 형식에 맞는 로직을 쉽게 추가하거나 교체할 수 있는 유연한 구조를 마련했습니다.

## 🛠️ 트러블 슈팅

### 1\. 외부 AI API 호출 시 타임아웃 문제 (Gemini API)

  * **문제**: 번역/요약에 사용되는 Gemini API는 응답 시간이 30초\~1분으로 긴 편입니다. 하지만 `Microsoft.Extensions.Http.Resilience`의 기본 타임아웃 정책(약 10초)이 이보다 짧아 API 호출 시 타임아웃 오류가 발생했습니다.

  * **해결**: `GeminiClient`라는 이름의 HttpClient 설정 시, `.RemoveAllResilienceHandlers()`를 사용해 기본 탄력성 정책을 제거했습니다. 그 후, `.AddResilienceHandler()`를 이용해 "CustomGeminiPolicy"라는 사용자 정의 정책을 추가하여 Gemini API 특성에 맞게 타임아웃(60초), 재시도(1회, 2초 후 지수 백오프), 서킷 브레이커 설정을 조정했습니다. HttpClient 자체의 `Timeout`은 `Timeout.InfiniteTimeSpan`으로 설정하여 Resilience 정책 레벨에서 타임아웃을 관리하도록 했습니다.

    ```csharp
    services.AddHttpClient("GeminiClient", (serviceProvider, client) =>
    {
        // ... (BaseAddress 설정 등) ...
        client.Timeout = Timeout.InfiniteTimeSpan; // HttpClient 자체 타임아웃은 무한으로
    })
    .RemoveAllResilienceHandlers() // 기본 핸들러 제거
    .AddResilienceHandler("CustomGeminiPolicy", config => // 사용자 정의 정책 추가
    {
        // 재시도 정책 (최대 1번, 2초 딜레이, 특정 조건에서)
        config.AddRetry(new HttpRetryStrategyOptions { /* ... 설정 ... */ });
        // 타임아웃 정책 (60초)
        config.AddTimeout(TimeSpan.FromSeconds(60));
        // 서킷 브레이커 정책 (3분간 20회 요청 중 80% 실패 시 15초간 차단)
        config.AddCircuitBreaker(new HttpCircuitBreakerStrategyOptions { /* ... 설정 ... */ });
    });
    ```

### 2\. 반송 이메일 처리의 복잡성 (Azure Communication Services Email)

  * **문제**: 초기에는 Azure Communication Services Email을 사용했으나, 반송이나 수신 거부 같은 중요한 이메일 전송 실패 이벤트를 선별적으로 구독할 수 없었습니다. 모든 이벤트를 받아 애플리케이션 레벨에서 필터링해야 하는 방식은 향후 평판 관리 로직 구현 시 복잡성을 증가시킬 것으로 판단했습니다.
  * **해결**: 이메일 발송 서비스를 AWS Simple Email Service (SES)로 변경했습니다. AWS SES는 반송, 수신 거부 등의 특정 이벤트만 선택적으로 구독하여 HTTP 요청을 받을 수 있어, 관련 처리 로직을 훨씬 단순하고 효율적으로 구현할 수 있습니다.

### 3\. 비정규 JSON 응답 처리 (Gemini API)

  * **문제**: Gemini API 응답에서 가끔 실제 JSON 객체 앞뒤로 불필요한 텍스트가 포함되어 오는 경우가 발생했습니다. 이로 인해 Json Deserialization 과정에서 오류를 일으켰습니다.

  * **해결**: 응답 문자열에서 유효한 JSON 부분만 추출하는 유틸리티 함수 `ExtractProcessedOutput`를 구현했습니다. 이 함수는 문자열 내 첫 번째 여는 중괄호(`{`)와 마지막 닫는 중괄호(`}`)를 찾아 그 사이의 내용을 추출하여 역직렬화를 시도합니다.

    ```csharp
    private static ProcessedOutput? ExtractProcessedOutput(string text)
    {
        var jsonStart = text.IndexOf('{');
        var jsonEnd = text.LastIndexOf('}');

        if (jsonStart < 0 || jsonEnd <= jsonStart)
            return null; // 유효한 JSON 구조를 찾을 수 없음

        var json = text[jsonStart..(jsonEnd + 1)]; // JSON 부분 추출

        try
        {
            return JsonSerializer.Deserialize<ProcessedOutput>(json);
        }
        catch (JsonException)
        {
            // 추출된 부분도 유효한 JSON이 아닐 경우 로깅 또는 null 반환
            return null;
        }
    }
    ```

-----
